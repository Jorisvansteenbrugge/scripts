#!/usr/bin/env python
import argparse
import subprocess as sp
import tempfile
import logging
import os
import glob 
import types

logging.basicConfig(level=20)
logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
qscore = 0.05

class Peak:
    prefix = ""
    tmpdir = ""
    path = ""

    def __init__(self, fileName=None, tmpdir=None, path=None):
        self.tmpdir = tmpdir
        if not path:
            self.prefix = os.path.basename(fileName).split(".bam")[0]
            self._callPeaks(fileName)
        else:
            self.path = path 

    def _callPeaks(self, fileName):
        logging.info("Starting peak calling for: {}".format(fileName))
        CMD = "macs2 callpeak -q {} -t {} -n {} --nomodel --nolambda".format(qscore, fileName, self.tmpdir+"/"+self.prefix)
        logging.info("Peakcall command: {}".format(CMD))
        sp.call(CMD, shell=True)
        logging.info("Peaks called for: {}".format(fileName))
        self.path = self.tmpdir + "/" + self.prefix + "_peaks.bed"

    def getPrefix(self):
        return self.prefix

    def getPath(self):
        return self.path

    def _intersectCount(self, bedfile):
        logging.info("intersecting {} & {}".format(self.getPath, bedfile))
        CMD = "bedtools intersect -a {} -b {} | wc -l".format(bedfile,self.getPath() )
        
        p = sp.Popen(CMD, shell=True, stdout=sp.PIPE)
        count = ""
        for line in p.stdout:
            count+=line
        logging.info("Count: {}".format(count))
        return int(count)
        
def getFirstExon(line):
    try:
        line = line.strip().split("\t")
        strand = line[5]
        if "+" in strand:
            start = int(line[1])
            newStart = start - 500 #boundary
            newEnd = start + 500 #boundary
        elif "-" in strand:
            start = int(line[2])
            newEnd = start + 500 #
            newStart = start - 500#

        out = [line[0],str(newStart),str(newEnd)]
        return "\t".join(out)
    except:
        return None

def getTotalGeneCount(bed):
    CMD = "cat {} | wc -l".format(bed)
    p = sp.Popen(CMD, shell=True, stdout=sp.PIPE)
    count = ""
    for line in p.stdout:
        count+=line
    logging.info("TotalGenes in {} = {}".format(bed, count))
    return int(count)

def parseArgs():
    p = argparse.ArgumentParser()
    p.add_argument("-p", dest="peakdir", help="Directory with H3K4me4 bam files", required = False)
    p.add_argument("-b", dest="bedFiles", nargs="+", help="Space seperated list of bed files to use. Minimum is 1, however the result of this would not be informative ;)", required = True)
    p.add_argument("-o", dest="outfile", help="Output data file", required = True)
    p.add_argument("-r", dest="reannotate", help="An existing peakcalling can be used to repeat the progress. The input can be either one file or multiple (space seperated)", required=False, nargs="+")
    logging.info("Arguments parsed")
    args = p.parse_args()

    if not args.peakdir:
        if not args.reannotate:
            logging.error("Either one of the following parameters needs to present: peakdir OR reannotate")

    return args

def parsePeakDir(h3k4List, r):
    tmpdir = tempfile.mkdtemp(prefix="peakStart.")
    logging.info("tempdir: {}".format(tmpdir))
    peakList = []
    for bamFile in h3k4List:
        if not r:
            peakList.append(Peak(fileName=bamFile, tmpdir=tmpdir))
        else:
            peakList.append(Peak(path=bamFile))
        logging.info("creating Peak obj {}".format(bamFile))
    return peakList, tmpdir

def prepOutfile(outfile):
    f = open(outfile,"w")
    f.write("annotation\tstage\tcount\n")
    f.close()

"""
Takes for everyline in the bedfile the positions of the start. That way it is easy to compare gene start with peaks 
"""
def getFirstExonBed(bedFile):
    bedFile = open(bedFile)
    outfile = tempfile.NamedTemporaryFile(delete=False, suffix = ".bed")
    for line in bedFile:
        out = getFirstExon(line)
        if out:
            outfile.write(out+"\n")
    outfile.flush()
    return outfile.name

def parseBed(peakList, bedList, outfile):
    outfile = open(outfile,"a")
    logging.info("bedList: {}".format(bedList))
    logging.info("peakList: {}".format(peakList))
    for bed in bedList:
        newBed = getFirstExonBed(bed)
        logging.info("In bed {}".format(bed))
        for peak in peakList:
            print(type(peak))
            print(peak)
            if type(peak) is list:
                peak = peak[0]
                
            try:
                peakCount = peak._intersectCount(newBed)
            except AttributeError:
                print(peak)
            geneCount = getTotalGeneCount(newBed)
            relativeCount = (peakCount*100)/geneCount
            logging.info("relativeCount for {} = {}".format(bed, relativeCount))
            outfile.write(os.path.basename(bed).replace(".bed","")+"\t"+peak.getPrefix()+"\t"+str(relativeCount)+"\n")
    outfile.close()
    

if __name__ == "__main__":
    #argument parsing
    args = parseArgs()
    bedFiles = args.bedFiles
    outfile = args.outfile
    r = False
    if not args.reannotate:
        #h3k4dir = args.peakdir
        #h3k4List = glob.glob("{}*.bam".format(h3k4dir))
        pass
    else:
        r = True
        h3k4List = args.reannotate
        print(h3k4List)

    peakList = parsePeakDir(h3k4List, r)
    prepOutfile(outfile)
    parseBed(peakList, bedFiles, outfile)
