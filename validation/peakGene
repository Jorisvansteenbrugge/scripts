#!/usr/bin/env python
import argparse
from os import path
import logging
import subprocess as sp
from glob import glob
from tempfile import NamedTemporaryFile as ntp

logging.basicConfig(level=20)
logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')

"""
Paring of command line arguments
"""
def parseArgs():
    p = argparse.ArgumentParser()
    p.add_argument("-p", dest="peakdir", help="Directory with Peak called bedfiles", required = True)
    p.add_argument("-b", dest="bedFiles", nargs="+", help="Space seperated list of bed files to use. Minimum is 1, however the result of this would not be informative ;)", required = True)
    p.add_argument("-o", dest="outfile", help="Output data file", required = True)
    logging.info("Arguments parsed")
    return p.parse_args()

"""
where the magic happens. 
"""
def parseBedFiles(bedFiles, peakdir, outfile):
    outPut = open(outfile,"w")
    outPut.write('"annotation"\t"stage"\t"count"\t"total"\n') 
    for bed in bedFiles: 
        #extract the bed file name
        entryName = path.basename(bed).replace(".bed","")

        #extract the first exon of each gene in the bed file
        parsedBedName = getFirstExonBed(bed)

        for peak in glob("{}/*_peaks.bed".format(peakdir)):
            stage = path.basename(peak).replace("H3K4me3_","").replace(".bed","")
            #Calculate the overlap count between peaks and bed genes
            CMD = "bedtools intersect  -a {} -b {} | wc -l".format(peak, parsedBedName)
            p = sp.Popen(CMD, shell=True, stdout = sp.PIPE)
            count = p.stdout.readline().strip()
           
            #Calculate the total amount of peaks in the bed file
            peakCount = getTotalPeakCount(peak)

            #writes output formatted to the outfile
            line = [entryName, stage,count, peakCount]
            outPut.write("\t".join(line)+"\n")

def getTotalPeakCount(path):
    CMD = "cat {} | wc -l".format(path)
    p = sp.Popen(CMD, shell=True, stdout = sp.PIPE)
    return p.stdout.readline().strip()

"""
This function extracts only the first exon from a bed entry and writes it to an output temp file.
Intersection later on now guarantees that the peak will be matched with the gene start only.
@bedFile The input bedfile in bed12 format
"""
def getFirstExonBed(bedFile):
    temp = ntp(delete=False)
    with open(bedFile) as inFile:
        for line in inFile:
            try:
                line = line.strip().split("\t")
                strand = line[5]
                start = int(line[1])
                end = int(line[2])
                blocks = int(line[9])
                blsizes = line[10].split(",")
                blstarts = line[11].split(",")
                if "+" in strand:
                    newStart = start+int(blstarts[0])
                    newEnd = newStart+int(blsizes[0])
                elif "-" in strand:
                    newStart = start+int(blstarts[blocks-1])
                    newEnd = newStart+int(blsizes[blocks-1])
                out = [line[0],str(newStart),str(newEnd)]
                temp.write("\t".join(out)+"\n") #strings are not mutable so join is quicker
            except:
                print("pass")
    temp.flush()
    return temp.name

"""
Starting the program
"""
if __name__ == "__main__":
    args = parseArgs()
    parseBedFiles(args.bedFiles, args.peakdir, args.outfile)


